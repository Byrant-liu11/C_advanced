#define _CRT_SECURE_NO_WARNINGS 1

//动态内存管理

//C语言提供了malloc函数和free函数进行动态内存开辟

//malloc函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
//void* malloc (size_t size);
//如果开辟成功，则返回一个指向开辟好空间的指针。
//如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
//返回值的类型是void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
//如果参数size 为0，malloc的行为是标准是未定义的，取决于编译器。

//free函数专门是用来做动态内存的释放和回收的
//void free (void* ptr);
//free函数用来释放动态开辟的内存。
//如果参数ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
//如果参数ptr 是NULL指针，则函数什么事都不做。
//在free(变量名)后，加上一句：变量名=NULL

//calloc函数用来动态内存分配
//void* calloc (size_t num, size_t size);
//函数的功能是为num 个大小为size 的元素开辟一块空间，并且把空间的每个字节初始化为0。
//与函数malloc 的区别只在于calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。

//realloc函数让动态内存管理更加灵活。
//有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，
//我们一定会对内存的大小做灵活的调整。那realloc 函数就可以做到对动态开辟内存大小的调整。
//void* realloc(void* ptr, size_t size);
//ptr 是要调整的内存地址
//size 调整之后新大小
//返回值为调整之后的内存起始位置。
//这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。
//realloc在调整内存空间的是存在两种情况：
//情况1：原有空间之后有足够大的空间
//情况2：原有空间之后没有足够大的空间

//常见的动态内存错误
//对NULL指针的解引用操作
//对动态开辟空间的越界访问
//对非动态开辟内存使用free释放
//使用free释放一块动态开辟内存的一部分
//对同一块动态内存多次释放
//动态开辟内存忘记释放（内存泄漏）
//忘记释放不再使用的动态开辟的空间会造成内存泄漏。 切记： 动态开辟的空间一定要释放，并且正确释放。
