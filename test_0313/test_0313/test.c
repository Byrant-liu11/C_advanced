#define _CRT_SECURE_NO_WARNINGS 1

//结构体变量的定义和初始化
//#include<stdio.h>
//struct Point
//{
//	int x;
//	int y;
//};
//struct Node
//{
//	struct Point p;
//	struct Node* next;
//};
//int main()
//{
//	struct Point p = { 3,5 };
//	printf("x=%d y=%d\n",p.x,p.y);
//
//	struct Node n = { {3,5},NULL };
//	printf("x=%d y=%d\n",n.p.x,n.p.y);
//
//	return 0;
//}

//结构体内存对齐
// 首先得掌握结构体的对齐规则：
//1. 第一个成员在与结构体变量偏移量为0的地址处。
//2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
//对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
//VS中默认的值为8
//3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
//4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
//体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
//练习1
//#include<stdio.h>
//struct S1
//{
//	char c1;
//	int i;
//	char c2;
//};
////练习2
//struct S2
//{
//	char c1;
//	char c2;
//	int i;
//};
////练习3
//struct S3
//{
//	double d;
//	char c;
//	int i;
//};
////练习4-结构体嵌套问题
//struct S4
//{
//	char c1;
//	struct S3 s3;
//	double d;
//};
//int main()
//{
//	printf("%d\n", sizeof(struct S1));//练习1
//
//	printf("%d\n", sizeof(struct S2));//练习2
//
//	printf("%d\n", sizeof(struct S3));//练习3
//
//	printf("%d\n", sizeof(struct S4));//练习4
//
//	return 0;
//}
//为什么存在内存对齐 ?
//大部分的参考资料都是如是说的：
//1. 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能
//在某些地址处取某些特定类型的数据，否则抛出硬件异常。
//2. 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的
//内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
//总体来说：
//结构体的内存对齐是拿空间来换取时间的做法。
//那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
//让占用空间小的成员尽量集中在一起。

//修改默认对齐数
//之前我们见过了#pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数。
//#include <stdio.h>
//#pragma pack(8)//设置默认对齐数为8
//struct S1
//{
//	char c1;
//	int i;
//	char c2;
//};
//#pragma pack()//取消设置的默认对齐数，还原为默认
//#pragma pack(1)//设置默认对齐数为8
//struct S2
//{
//	char c1;
//	int i;
//	char c2;
//};
//#pragma pack()//取消设置的默认对齐数，还原为默认
//int main()
//{
//	//输出的结果是什么？
//	printf("%d\n", sizeof(struct S1));
//	printf("%d\n", sizeof(struct S2));
//	return 0;
//}
//结论：
//结构在对齐方式不合适的时候，我么可以自己更改默认对齐数。

//百度笔试题：
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//考察:offsetof 宏的实现


//结构体传参
//#include<stdio.h>
//struct S
//{
//	int data[1000];
//	int num;
//};
//struct S s = { {1,2,3,4}, 1000 };
////结构体传参
//void print1(struct S s)
//{
//	printf("%d\n", s.num);
//}
////结构体地址传参
//void print2(struct S* ps)
//{
//	printf("%d\n", ps->num);
//}
//int main()
//{
//	print1(s); //传结构体
//	print2(&s); //传地址
//	return 0;
//}
//上面的print1 和print2 函数哪个好些？
//答案是：首选print2函数。 原因：
//函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
//如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能
//的下降。
//结论： 结构体传参的时候，要传结构体的地址。

//位段
//结构体讲完就得讲讲结构体实现位段的能力。
//什么是位段
//位段的声明和结构是类似的，有两个不同：
//1.位段的成员必须是int、unsigned int 或signed int 。
//2.位段的成员名后边有一个冒号和一个数字。
//#include<stdio.h>
//struct A
//{
//	int _a : 2;
//	int _b : 5;
//	int _c : 10;
//	int _d : 30;
//};
////A就是一个位段类型。
////那位段A的大小是多少？
//int main()
//{
//	printf("%d\n", sizeof(struct A));
//	return 0;
//}
//位段的内存分配
//1. 位段的成员可以是int unsigned int signed int 或者是char （属于整形家族）类型
//2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
//一个例子
//#include<stdio.h>
//struct S
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//int main()
//{
//	struct S s = { 0 };
//	s.a = 10;
//	s.b = 12;
//	s.c = 3;
//	s.d = 4;
//	//空间是如何开辟的？
//	printf("%d\n", sizeof(struct S));
//	return 0;
//}
//位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机
//器会出问题。
//3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
//4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是
//舍弃剩余的位还是利用，这是不确定的。
//总结：
//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。


//枚举
//枚举顾名思义就是一一列举。
//把可能的取值一一列举。
//枚举类型的定义
//enum Day//星期
//{
//	Mon,
//	Tues,
//	Wed,
//	Thur,
//	Fri,
//	Sat,
//	Sun
//};
//enum Sex//性别
//{
//	MALE,
//	FEMALE,
//	SECRET
//};
//enum Color//颜色
//{
//	RED,
//	GREEN,
//	BLUE
//};
//以上定义的enum Day ， enum Sex ， enum Color 都是枚举类型。 {}中的内容是枚举类型的可能取
//值，也叫枚举常量。
//这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。 例如：
//enum Color//颜色
//{
//	RED = 1,
//	GREEN = 2,
//	BLUE = 4
//};
//枚举的优点
//为什么使用枚举？
//我们可以使用#define 定义常量，为什么非要使用枚举？ 枚举的优点：
//1. 增加代码的可读性和可维护性
//2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
//3. 防止了命名污染（封装）
//4. 便于调试
//5. 使用方便，一次可以定义多个常量
//枚举的使用
//enum Color//颜色
//{
//	RED = 1,
//	GREEN = 2,
//	BLUE = 4
//};
//enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
//clr = 5; //ok??

//联合（共用体）
//联合类型的定义
//联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块
//空间（所以联合也叫共用体）。 比如：
//联合类型的声明
//union Un
//{
//	char c;
//	int i;
//};
////联合变量的定义
//int main()
//{
//	union Un un;
//	//计算连个变量的大小
//	printf("%d\n", sizeof(un));
//	return 0;
//}
//联合的特点
//联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为
//联合至少得有能力保存最大的那个成员）。
//union Un
//{
//	int i;
//	char c;
//};
//int main()
//{
//	union Un un;
//	// 下面输出的结果是一样的吗？
//	printf("%d\n", &(un.i));
//	printf("%d\n", &(un.c));
//	//下面输出的结果是什么？
//	un.i = 0x11223344;
//	un.c = 0x55;
//	printf("%x\n", un.i);
//	return 0;
//}
//联合大小的计算
//联合的大小至少是最大成员的大小。
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。
//union Un1
//{
//	char c[5];
//	int i;
//};
//union Un2
//{
//	short c[7];
//	int i;
//};
//int main()
//{
//	//下面输出的结果是什么？
//	printf("%d\n", sizeof(union Un1));
//	printf("%d\n", sizeof(union Un2));
//}